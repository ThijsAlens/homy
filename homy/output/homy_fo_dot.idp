vocabulary V {
	// DEFAULT NEEDED TYPES AND FUNCTIONS
	type StringDevice := {light_1, light_2, light_3, light_switch_1}
	type NumberDevice := {}
	type StringState := {add a new state}
	type Area := {home}
	time: () -> Int


	stringDeviceIsInArea: StringDevice -> Area
	numberDeviceIsInArea: NumberDevice -> Area
	// subArea * superArea -> Bool
	areaIsSubAreaOf: Area * Area -> Bool


	stringDeviceIsInState: StringDevice -> StringState
	numberDeviceIsInState: NumberDevice -> Int
	// GENERATED VOCABULARY


	type nullDevice := {light_1, light_2, light_3, light_switch_1} <: StringDevice
	type nullDeviceStates := {null, null} <: StringState
	type nullDevice := {light_1, light_2, light_3, light_switch_1} <: StringDevice
	type nullDeviceStates := {null, null} <: StringState
}
theory T : V {
	!dt in nullDevice: ?x in nullDeviceStates: stringDeviceIsInState(dt) = x.
	!dt in nullDevice: ?x in nullDeviceStates: stringDeviceIsInState(dt) = x.
	(  (stringDeviceIsInState(null) = null)) => (  (stringDeviceIsInState(null) = null)).
	(  (stringDeviceIsInState(null) = null)) => (    (stringDeviceIsInState(null) = null) &   (stringDeviceIsInState(null) = null) ).
	(  (stringDeviceIsInState(null) = null)) => (  (stringDeviceIsInState(null) = null)).
	!d in nullDevice: ((stringDeviceIsInArea(d) = home) &   (stringDeviceIsInState(null) = null)) => (stringDeviceIsInState(d) = null).
}
structure S : V {
	stringDeviceIsInArea := {light_1 -> home, light_2 -> home, light_3 -> home, light_switch_1 -> home} .
	numberDeviceIsInArea := {} .
	areaIsSubAreaOf := {(home, home), (home, home)} .
}